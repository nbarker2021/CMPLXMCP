"""
Identity Family System
======================
Orchestrates SNAP, MDHG, MMDB, Lambda, and Glyph systems.

Every atomic action is:
1. Recorded in SNAP (transaction log)
2. Given a Speedlight receipt (cryptographic proof)
3. Stored as a labeled crystal (morphon-based)
4. Linked to identity (who did it)
5. Connected to temporal context (when/what phase)

This creates a unified identity-aware storage system where
everything is traceable, verifiable, and resonant.
"""

import hashlib
import json
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Optional
from pathlib import Path
import sqlite3

from .snap_atom import SNAPLedger, SNAPTransaction
from .crystal import Crystal, CrystalLattice, CrystalFactory
from .temporal import TemporalLayer


@dataclass
class SpeedlightReceipt:
    """
    A cryptographic receipt generated by Speedlight.
    
    Proves that:
    1. An action occurred
    2. It was performed by a specific identity
    3. At a specific time
    4. With specific inputs/outputs
    
    Receipts are tamper-evident and auditable.
    """
    
    receipt_id: str
    tx_id: str  # Links to SNAP transaction
    
    # Cryptographic proof
    input_hash: str  # Hash of input data
    output_hash: str  # Hash of output data
    action_hash: str  # Hash of action description
    
    # Signature
    identity_signature: str  # Signed by identity's key
    system_signature: str  # Signed by system
    
    # Timestamp
    timestamp: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    
    # Verification
    nonce: str = field(default_factory=lambda: hashlib.sha256(
        datetime.utcnow().isoformat().encode()
    ).hexdigest()[:16])
    
    def verify(self) -> bool:
        """Verify receipt integrity."""
        # Recompute hashes
        computed_action = hashlib.sha256(
            f"{self.tx_id}:{self.timestamp}".encode()
        ).hexdigest()[:32]
        
        return computed_action == self.action_hash
    
    def to_dict(self) -> dict:
        return {
            "receipt_id": self.receipt_id,
            "tx_id": self.tx_id,
            "input_hash": self.input_hash,
            "output_hash": self.output_hash,
            "action_hash": self.action_hash,
            "identity_signature": self.identity_signature,
            "system_signature": self.system_signature,
            "timestamp": self.timestamp,
            "nonce": self.nonce,
        }


@dataclass
class Identity:
    """
    An identity in the CMPLX system.
    
    Identities are:
    - Cryptographically verifiable
    - Have a history (SNAP chain)
    - Own crystals
    - Generate receipts
    """
    
    identity_id: str
    name: str
    
    # Keys (simplified - would use proper crypto)
    public_key: str = ""
    private_key_hash: str = ""  # Never store actual private key!
    
    # History
    created_at: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    tx_count: int = 0
    
    # Owned crystals
    crystal_ids: list[str] = field(default_factory=list)
    
    # Reputation
    reputation_score: float = 1.0
    
    def sign(self, data: str) -> str:
        """Sign data with identity's key."""
        # Simplified signing
        content = f"{self.identity_id}:{data}:{self.private_key_hash[:8]}"
        return hashlib.sha256(content.encode()).hexdigest()[:32]
    
    def verify(self, data: str, signature: str) -> bool:
        """Verify signature."""
        expected = self.sign(data)
        return expected == signature


class IdentityFamily:
    """
    The Identity Family orchestrates all systems.
    
    For every atomic action:
    1. SNAP records the transaction
    2. Speedlight generates a receipt
    3. Crystal stores the geometric form
    4. Temporal layer places it in time
    5. Identity claims ownership
    
    This creates a complete provenance chain.
    """
    
    def __init__(self, 
                 lattice: CrystalLattice,
                 temporal: TemporalLayer,
                 db_path: Path | str = "identity_family.db"):
        self.lattice = lattice
        self.temporal = temporal
        self.snap = SNAPLedger()
        self.db_path = Path(db_path)
        
        self._identities: dict[str, Identity] = {}
        self._receipts: dict[str, SpeedlightReceipt] = {}
        
        self._init_db()
    
    def _init_db(self):
        """Initialize identity family storage."""
        with sqlite3.connect(self.db_path) as conn:
            conn.executescript("""
                CREATE TABLE IF NOT EXISTS identities (
                    identity_id TEXT PRIMARY KEY,
                    name TEXT,
                    public_key TEXT,
                    created_at TEXT,
                    reputation_score REAL
                );
                
                CREATE TABLE IF NOT EXISTS receipts (
                    receipt_id TEXT PRIMARY KEY,
                    tx_id TEXT,
                    identity_id TEXT,
                    crystal_id TEXT,
                    json_data TEXT,
                    timestamp TEXT
                );
                
                CREATE INDEX IF NOT EXISTS idx_receipt_tx ON receipts(tx_id);
                CREATE INDEX IF NOT EXISTS idx_receipt_identity ON receipts(identity_id);
                CREATE INDEX IF NOT EXISTS idx_receipt_crystal ON receipts(crystal_id);
                
                CREATE TABLE IF NOT EXISTS identity_crystals (
                    identity_id TEXT,
                    crystal_id TEXT,
                    relationship TEXT,
                    acquired_at TEXT,
                    PRIMARY KEY (identity_id, crystal_id)
                );
            """)
            conn.commit()
    
    def register_identity(self, name: str, identity_id: str | None = None) -> Identity:
        """Register a new identity."""
        identity = Identity(
            identity_id=identity_id or f"id_{hashlib.sha256(name.encode()).hexdigest()[:16]}",
            name=name,
            public_key=hashlib.sha256(f"{name}_pub".encode()).hexdigest()[:32],
            private_key_hash=hashlib.sha256(f"{name}_priv".encode()).hexdigest()[:32]
        )
        
        self._identities[identity.identity_id] = identity
        
        # Store
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                """INSERT INTO identities 
                   (identity_id, name, public_key, created_at, reputation_score)
                   VALUES (?, ?, ?, ?, ?)""",
                (identity.identity_id, identity.name, identity.public_key,
                 identity.created_at, identity.reputation_score)
            )
            conn.commit()
        
        return identity
    
    def get_identity(self, identity_id: str) -> Optional[Identity]:
        """Get identity by ID."""
        return self._identities.get(identity_id)
    
    async def atomic_action(self,
                          identity_id: str,
                          action_type: str,
                          geometric_form,
                          input_handles: list[str] = None,
                          description: str = "",
                          temporal_phase: str = "present") -> dict:
        """
        Execute an atomic action with full provenance.
        
        This is THE method for all atomic operations.
        It orchestrates SNAP, Speedlight, Crystals, and Temporal layer.
        
        Returns:
            Dictionary with handles for everything created.
        """
        identity = self.get_identity(identity_id)
        if not identity:
            raise ValueError(f"Unknown identity: {identity_id}")
        
        now = datetime.utcnow().isoformat()
        
        # 1. Create crystal from geometric form
        from .crystal import CrystalFactory
        from .translator import GeometricForm
        
        crystal = CrystalFactory.from_geometric_form(
            geometric_form,
            name=f"{action_type}_{now}",
            temporal_phase=temporal_phase,
            tags=[action_type, identity_id]
        )
        
        # Store crystal
        crystal_id = self.lattice.store(crystal)
        
        # 2. Record in SNAP
        tx = self.snap.record(
            action_type=action_type,
            identity=identity_id,
            input_handles=input_handles or [],
            output_handle=crystal_id,
            input_signature=geometric_form.symmetry_signature if hasattr(geometric_form, 'symmetry_signature') else "",
            output_signature=crystal.resonance_signature,
            description=description,
            temporal=temporal_phase,
            atoms=[a.atom_id for a in crystal.atoms],
            bonds=[f"{b.source_id}->{b.target_id}" for b in crystal.bonds]
        )
        
        # Link crystal to transaction
        crystal.snap_tx_id = tx.tx_id
        self.lattice.store(crystal)  # Update
        
        # 3. Generate Speedlight receipt
        receipt = SpeedlightReceipt(
            receipt_id=f"rcpt_{tx.tx_id[:16]}",
            tx_id=tx.tx_id,
            input_hash=tx.input_signature or hashlib.sha256(
                json.dumps(input_handles or []).encode()
            ).hexdigest()[:32],
            output_hash=crystal.resonance_signature,
            action_hash=hashlib.sha256(action_type.encode()).hexdigest()[:32],
            identity_signature=identity.sign(tx.tx_id),
            system_signature=hashlib.sha256(f"system:{tx.tx_id}".encode()).hexdigest()[:32]
        )
        
        self._receipts[receipt.receipt_id] = receipt
        
        # Store receipt
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                """INSERT INTO receipts
                   (receipt_id, tx_id, identity_id, crystal_id, json_data, timestamp)
                   VALUES (?, ?, ?, ?, ?, ?)""",
                (receipt.receipt_id, tx.tx_id, identity_id, crystal_id,
                 json.dumps(receipt.to_dict()), now)
            )
            
            # Link identity to crystal
            conn.execute(
                """INSERT INTO identity_crystals
                   (identity_id, crystal_id, relationship, acquired_at)
                   VALUES (?, ?, 'creator', ?)""",
                (identity_id, crystal_id, now)
            )
            
            conn.commit()
        
        # 4. Handle temporal placement
        if temporal_phase == "past":
            # It's a memory
            self.temporal.remember(crystal, description)
        elif temporal_phase == "future":
            # It's a hypothesis
            pass  # Handled by hypothesis engine
        
        # Update identity
        identity.tx_count += 1
        identity.crystal_ids.append(crystal_id)
        
        return {
            "crystal_id": crystal_id,
            "tx_id": tx.tx_id,
            "receipt_id": receipt.receipt_id,
            "identity_id": identity_id,
            "timestamp": now,
            "temporal_phase": temporal_phase,
            "resonance_signature": crystal.resonance_signature,
            "verified": receipt.verify()
        }
    
    def audit(self, crystal_id: str) -> dict:
        """
        Audit a crystal's complete provenance.
        
        Returns full chain: receipt → transaction → identity → lineage
        """
        # Get receipt
        with sqlite3.connect(self.db_path) as conn:
            row = conn.execute(
                "SELECT json_data FROM receipts WHERE crystal_id = ?",
                (crystal_id,)
            ).fetchone()
            
            receipt_data = json.loads(row[0]) if row else None
        
        # Get crystal
        crystal = self.lattice.retrieve(crystal_id)
        
        # Get transaction
        tx = self.snap.chain.get(crystal.snap_tx_id) if crystal else None
        
        # Get lineage
        lineage = self.lattice.get_lineage(crystal_id) if crystal else {}
        
        return {
            "crystal_id": crystal_id,
            "receipt": receipt_data,
            "transaction": tx.to_dict() if tx else None,
            "crystal": crystal.to_dict() if crystal else None,
            "lineage": lineage,
            "verified": all([
                receipt_data and SpeedlightReceipt(**receipt_data).verify(),
                tx and tx.verify() if tx else False,
                crystal is not None
            ])
        }
    
    def get_identity_history(self, identity_id: str) -> dict:
        """Get complete history of an identity."""
        identity = self.get_identity(identity_id)
        if not identity:
            return {"error": "Identity not found"}
        
        # Get all transactions
        txs = self.snap.chain.get_by_identity(identity_id)
        
        # Get all receipts
        with sqlite3.connect(self.db_path) as conn:
            rows = conn.execute(
                "SELECT crystal_id FROM identity_crystals WHERE identity_id = ?",
                (identity_id,)
            ).fetchall()
            
            crystal_ids = [r[0] for r in rows]
        
        return {
            "identity": identity.__dict__,
            "transaction_count": len(txs),
            "transactions": [tx.to_dict() for tx in txs],
            "crystal_count": len(crystal_ids),
            "crystal_ids": crystal_ids,
            "reputation": identity.reputation_score
        }
    
    def verify_receipt(self, receipt_id: str) -> bool:
        """Verify a receipt's authenticity."""
        receipt = self._receipts.get(receipt_id)
        if not receipt:
            # Load from DB
            with sqlite3.connect(self.db_path) as conn:
                row = conn.execute(
                    "SELECT json_data FROM receipts WHERE receipt_id = ?",
                    (receipt_id,)
                ).fetchone()
                
                if row:
                    data = json.loads(row[0])
                    receipt = SpeedlightReceipt(**data)
                    self._receipts[receipt_id] = receipt
        
        return receipt.verify() if receipt else False
    
    def stats(self) -> dict:
        """Get identity family statistics."""
        return {
            "identities": len(self._identities),
            "total_transactions": self.snap.get_stats(),
            "total_receipts": len(self._receipts),
            "crystal_lattice": self.lattice.stats(),
        }
